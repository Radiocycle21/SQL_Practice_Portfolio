/*
----------------------------------------------------------------------------------------------------
-- Day 5 -- 

Problem count - 12
----------------------------------------------------------------------------------------------------
*/

-- Problem 1 -- 

/*
Find the top 2 products with the highest revenue for each category. 
In the case of a tie in revenue, the product with the lower product_id should be ranked higher.
The result should include product_name, category, and revenue. 
If a category has fewer than 2 products, list all of them.
*/

select * 
from (
    select 
        p.product_id,
        p.product_name,
        p.category,
        s.revenue,
        row_number() over (partition by category order by s.revenue desc, p.product_id asc) as ranking
    from products p 
    join sales s  
    on p.product_id = s.product_id
)t 
where ranking <=2;

-- Problem 2 -- 

/*
Calculate the running total of total_amount for each customer. 
The running total should only consider orders placed within the last 30 days, starting from the current date. 
The result should show the customer_id, order_date, and the cumulative total_amount up to that date, ordered chronologically.
*/

select 
    customer_id,
    order_date,
    total_amount,
    datediff(day, order_date, getdate()) as last_30days,
    sum(total_amount) over (partition by customer_id order by order_date desc) as cumulative_order
from orders
where  datediff(day, order_date, getdate()) <=30;

-- problem 3 -- 

/*
Find all departments where every single employee earns a salary of at least $50,000. 
For these departments, list the dept_name and the number of employees who meet this condition.
*/ 

select 
    e.dept_id,
    d.dept_name,
    count(e.emp_id) as count_employees,
    count(case when e.salary >= 50000 then 1 end ) as count_employees_morethan_50000
from employees e  
join department d  
on e.dept_id = d.dept_id 
group by  
        e.dept_id,
        d.dept_name
having count(e.emp_id) = count(case when e.salary >= 50000 then 1 end );

-- just to compare the results of both the columns without the filter condition
select 
    e.dept_id,
    d.dept_name,
    count(e.emp_id) as count_employees,
    count(case when e.salary >= 50000 then 1 end ) as count_employees_morethan_50000
from employees e  
join department d  
on e.dept_id = d.dept_id 
group by  
        e.dept_id,
        d.dept_name;

-- problem 4 -- 

/*
Identify periods of consecutive daily activity for each customer. 
In other words, find the start date and end date of every streak where a customer placed at least one order on several consecutive calendar days.
The result should show the customer_id, the streak_start_date (the earliest date in the streak), and the streak_end_date (the latest date in the streak).
*/

with customer_ranking as (
select 
    customer_id,
    order_date,
    row_number() over (partition by customer_id order by order_date) as rn
from orders 
),
difference_days as (
select 
    customer_id,
    order_date,
    datediff(day, '1990-01-01', order_date) - rn as difference_date 
from customer_ranking
)
select 
    customer_id,
    min(order_date) as streak_start_date,
    max(order_date) as streak_end_date,
    count(*) as sterak_length
from difference_days
group by customer_id, difference_date
having count(*) >= 2;

-- problem 5 -- 

/*
The orders table may have duplicate entries for the same order, with a more recent entry representing a correction or update.
Remove duplicates and keep only the latest entry for each order_id. 
The latest entry is determined by the most recent order_date. 
The result should show the full, deduplicated orders table.
*/

select * 
from (
select 
    order_id,
    customer_id,
    order_date,
    total_amount,
    row_number() over (partition by order_id order by order_date desc) as ranking
from orders
)t 
where ranking = 1;

-- problem 6 -- 

/*
A daily activity session is defined as a series of consecutive days on which a specific customer placed an order.
Write a query to assign a unique daily_session_id to each continuous streak of ordering activity for every customer.
*/

with customer_ranking as (
select 
    customer_id,
    order_date,
    row_number() over (partition by customer_id order by order_date) as ranking 
from orders
),
date_difference as (
select 
    customer_id,
    order_date,
    datediff(day, '1990-01-01', order_date) - ranking as days_diff 
from customer_ranking
)
select 
    customer_id,
    order_date,
    row_number() over (partition by customer_id, days_diff order by order_date ) as unique_id,
    dense_rank() over( partition by customer_id order by days_diff asc) as daily_session_id
from date_difference
order by customer_id, order_date;

-- Problem 7 -- 

/*
For each day in the orders table, calculate two things for the given customer:

Running Total of Sales: The cumulative sum of all total_amount for that customer up to and including the current order_date.

3-Order Moving Average: The average total_amount of the current order and the two previous orders for that customer.
*/

select 
    order_id,
    customer_id,
    order_date,
    total_amount,
    sum(total_amount) over (partition by customer_id order by order_date) as cumulative_total,
    avg(total_amount) over(partition by customer_id order by order_date rows between 2 preceding and current row ) as moving_average
from orders
order by customer_id, order_date;

-- Problem 8 -- 

/* 
For each customer, identify the date of their third-to-last order and the running total of their sales up to that date (inclusive).
If a customer has fewer than three orders, return nothing for them.
*/

select * 
from (
select
    customer_id,
    order_id,
    order_date,
    row_number() over (partition by customer_id order by order_date) as ranking,
    sum(total_amount) over (partition by customer_id order by order_date ) as cumulative_total 
from orders
)t 
where ranking = 3;

-- problem 9 -- 

-- Find the customer_id and the total dollar amount of their orders only if that customer's very first order was for an amount greater than $100.

WITH CustomerFirstOrder AS (
    SELECT
        customer_id,
        total_amount,
        FIRST_VALUE(total_amount) OVER ( PARTITION BY customer_id ORDER BY order_date ASC ) AS first_order_amount
    FROM orders
)
SELECT
    customer_id,
    SUM(total_amount) AS total_lifetime_sales
FROM CustomerFirstOrder
WHERE first_order_amount > 100
GROUP BY customer_id;

-- problem 10 -- 

/*
Classify each customer based on the average dollar amount they spent per distinct ordering session, 
not just their lifetime total.

A customer's ordering session is defined as a series of orders placed on consecutive days.

Write a query that lists the customer_id, their average sales per session (rounded to 2 decimal places), 
and their final customer_tier based on the following criteria:

Average Sales Per Session	Customer Tier
≤$500	                    Standard
>$500 and ≤$1500	        High-Value
>$1500	                    Premium
*/

with customer_ranking as (
select 
    customer_id,
    sale_date,
    revenue,
    row_number() over (partition by customer_id order by sale_date) as ranking 
from sales
),
date_difference as (
    select 
        customer_id,
        sale_date,
        revenue,
        DATEDIFF(day, '1990-01-01', sale_date) - ranking as datedifference 
    from customer_ranking 
),
unique_sessions as (
    select 
        customer_id,
        revenue,
        dense_rank() over(partition by customer_id order by datedifference) as daily_sessions_id,
        sum(revenue) as session_total_sales
    from date_difference
    group by    customer_id,
                revenue,
                datedifference
)
select 
    round(avg(session_total_sales),2) as avg_sales_per_session,
    case 
        when avg(session_total_sales) <= 500 then 'Standard'
        when avg(session_total_sales) <= 1500 then 'High_value'
        else 'Premium' 
    end as customer_tier 
from unique_sessions
group by customer_id 
order by customer_id;

-- Problem 11 -- 

/*
Identify the customer_id who have purchased a product from the 'Electronics' category but have never purchased a product from the 'Apparel' category.
*/

SELECT
    DISTINCT O.customer_id
FROM
    orders O -- Source of customer_id
INNER JOIN
    order_details OD ON O.order_id = OD.order_id -- Links order to product
INNER JOIN
    products P ON OD.product_id = P.product_id -- Links product to category
WHERE
    -- 1. Filter the OUTER query to only include customers who bought Electronics (Set A)
    P.category = 'Electronics'

    -- 2. Subtract the set of customers who bought Apparel (Set B)
    AND O.customer_id NOT IN (
        SELECT
            T1.customer_id
        FROM
            orders T1 -- Source of customer_id
        INNER JOIN
            order_details T2 ON T1.order_id = T2.order_id -- Link to get product_id
        INNER JOIN
            products T3 ON T2.product_id = T3.product_id
        WHERE
            T3.category = 'Apparel'
    );

    -- problem 12 -- 

-- Find the customer_id, the order_date, and the total_amount of the very first order a customer placed immediately after they placed an order totaling over $100.
-- If a customer has no orders over $1000, or if they have no subsequent orders, they should not be included.


select * 
from (
select 
    customer_id,
    order_date,
    total_amount,
    lag(total_amount, 1) over (partition by customer_id order by order_date) as previous_order_amount
from orders
)t 
where previous_order_amount > 100
order by customer_id, order_date;